import numpy as np
import re
from isolated_node_cleaner import filter_connected_node_loose

def placed_arr(placed_all):
    placed_all_arr=np.empty((len(placed_all),len(placed_all[0])),dtype=object)
    for i in range(len(placed_all)):
            line = placed_all[i]
            placed_all_arr[i]=line

    placed_all_arr[:,1:4]=placed_all_arr[:,1:4].astype(float)
    placed_all_arr[:,6]=placed_all_arr[:,6].astype(int)
    res_id=np.unique(placed_all_arr[:,6]).astype(int)
    return placed_all_arr,res_id

def fetch_node_withidx(placed_node,idx_list):
    res_id_list = [i+1 for i in idx_list ]
    res=[]
    for n in res_id_list:
        res.append(placed_node[placed_node[:,6]==n])
    return np.vstack(res)

    
def fetch_edge_withidx(placed_edge,idx_list):
    res_id_list = [-1*i-1 for i in idx_list ]
    res=[]
    for n in res_id_list:
        res.append(placed_edge[placed_edge[:,6]==n])
    return np.vstack(res)

def fetch_edge_withidx_sep(placed_edge,idx_list):
    res_id_list = [-1*i-1 for i in idx_list ]
    res=[]
    for n in res_id_list:
        res.append(placed_edge[placed_edge[:,6]==n])
    return res

def temp_xyz(output,placed_all):
    atoms_number = len(placed_all)
    newxyz = []
    with open( output, "w") as fp:
        newxyz.append(str(atoms_number) + "\n" + "generated by MOF_BUILD" + "\n")
        for i in range(atoms_number):

            value_label = placed_all[i][0]   # atom_label
            value_label = re.sub(r"\d", "", value_label)
            value_x = float(placed_all[i][1])  # x
            value_y = float(placed_all[i][2])   # y
            value_z = float(placed_all[i][3])   # z
            formatted_line = "%-5s%8.3f%8.3f%8.3f" % (
                value_label,
                value_x,
                value_y,
                value_z,
            )
            newxyz.append(formatted_line + "\n")
        fp.writelines(newxyz)

def fc_assign_res_idx(placed_all,sc_unit_cell):
    placed_all_arr=np.empty((len(placed_all),len(placed_all[0])),dtype=object)
    for i in range(len(placed_all)):
        line = placed_all[i]
        placed_all_arr[i]=line

    placed_all_arr[:,1:4]=placed_all_arr[:,1:4].astype(float)
    placed_all_arr[:,6]=placed_all_arr[:,6].astype(int)
    res_id=list(np.unique(placed_all_arr[:,6]).astype(int))
    
    res_id.sort(reverse=True)
    res_list=[]
    for i in range(len(res_id)):
        r_id = res_id[i]
        res_arr= placed_all_arr[placed_all_arr[:,6]==r_id]
        vec = res_arr[:,1:4]
        cvec = np.dot(np.linalg.inv(sc_unit_cell),vec.T).T
        #moded_cvec = np.mod(cvec, 1)
        #cvec=moded_cvec   
        res_arr[:,1:4] = cvec
        res_arr[:,6] = i+1
        res_list.append(res_arr)

    return np.vstack((res_list))

            
def supercell_array(supercell,array):
    s_cell_list=[]
    s_cell_list_append = s_cell_list.append
    for i in supercell:
        points = array[:,1:4]
        new_points= points+i
        new_array=np.hstack((array[:,0:1],new_points,array[:,4:]))
        s_cell_list_append(new_array)
    return np.vstack((s_cell_list))

def fetch_rescount_targetall(target_all):
    already=[]
    rescount = []
    already_append=already.append
    rescount_append = rescount.append
    for i in target_all[:,-2]:
        if i not in already:
            already_append(i)
        if i in already:
            rescount_append(len(already))
    return already,rescount

def split_diffs(diffs):
    diff_ele=[]
    diff_ele_append = diff_ele.append
    dx=np.array([1,0,0])
    dy=np.array([0,1,0])
    dz=np.array([0,0,1])

    for i in diffs:
        x,y,z = i
        if x !=0:
            diffx= (x*dx).tolist()
            if diffx not in diff_ele:
                diff_ele_append(diffx)
        if y !=0:
            diffy= (y*dy).tolist()
            if diffy not in diff_ele:
                diff_ele_append(diffy)
        if z !=0:
            diffz= (z*dz).tolist()
            if diffz not in diff_ele:
                diff_ele_append(diffz)
        if x*y !=0:
            diffxy = (x*dx+y*dy).tolist()
            if diffxy not in diff_ele:
                diff_ele_append(diffxy)
        if x*z !=0:
            diffxz = (x*dx+z*dz).tolist()
            if diffxz not in diff_ele:
                diff_ele_append(diffxz)
        if y*z !=0:
            diffyz = (y*dy+z*dz).tolist()
            if diffyz not in diff_ele:
                diff_ele_append(diffyz)
        if x*y*z !=0:
            diffxyz = (x*dx+y*dy+z*dz).tolist()
            if diffxyz not in diff_ele:
                diff_ele_append(diffxyz)
    return diff_ele

def check_edge_center_inbox(center,box_bound):
    a,b,c = box_bound
    x,y,z = center
    return (0<=x<=a and 0<=y<=b and 0<=z<=c)

def check_edge_center_inbox_loose(center,box_bound,scalar):
    a,b,c = box_bound
    x,y,z = center
    if (0<=x<=a and 0<=y<=b and 0<=z<=c):
        return True
    elif (-1*scalar<=x<=a+scalar and 0<=y<=b and 0<=z<=c):
        return True
    elif (0<=x<=a and -1*scalar<=y<=b+scalar and 0<=z<=c):
        return True
    elif (0<=x<=a and 0<=y<=b and -1*scalar<=z<=c+scalar):
        return True
    else:
        return False
    


def check_edgex_sits_inboundary(pointx1,pointx2,box_bound):
    a,b,c = box_bound
    pointx1 = pointx1.astype(float)
    pointx1 = np.round(pointx1,2)
    pointx2 = pointx2.astype(float)
    pointx2 = np.round(pointx2,2)
    doublecheck = check_edge_center_inbox(pointx1,box_bound) and check_edge_center_inbox(pointx2,box_bound) 
    return doublecheck
    

def check_nodex_inbox(nodex,box_bound):
    a,b,c = box_bound
    x,y,z = nodex
    return (0<x<=a and 0<y<=b and 0<z<=c)

def diff_rows_count_two_array(array0,array1):
    array0 = array0.astype(float)
    array1 = array1.astype(float)
    arr0= np.round(array0,3)
    arr1= np.round(array1,3)
    list0=[i for i in arr0]
    list1=[i for i in arr1]
    diff_rows=[i for i in range(len(list0)) if list0[i].tolist()!=list1[i].tolist()]
    return diff_rows


def filt_edgex_fvec(array):
    edgex_fvec=np.asarray([i for i in array if i[4]=='EDGE' and re.sub('[0-9]','',i[2]) == 'X'])
    return edgex_fvec

def filt_edgex_fvec_tetra(array):
    edgex_fvec=np.asarray([i for i in array if i[4]=='TEDGE' and re.sub('[0-9]','',i[2]) == 'X'])
    return edgex_fvec

def check_overlapX(edgex_cvec,nodex_cvec):
    dist_arr=edgex_cvec-nodex_cvec
    for i in dist_arr:
        if np.linalg.norm(i) <0.01:
            return True
    return False


def limit_x_range(x,a,b,l):
    if x >b:
        while x>b:
            x=x-l
        return x
    elif x<a:
        while x< a:
            x = x+l
        return x
    else:
        return x
    

def cut_boundary(arr,box_bound,buffer,cutx,cuty,cutz):
    box_bound_xl,box_bound_yl,box_bound_zl = box_bound 
    box_bound_xmin,box_bound_xmax = 0+buffer,box_bound_xl-buffer
    box_bound_ymin,box_bound_ymax = 0+buffer,box_bound_yl-buffer
    box_bound_zmin,box_bound_zmax = 0+buffer,box_bound_zl-buffer
    new_arr = np.empty(arr.shape)
    for i in range(len(arr)):
        if cutx:
            new_arr[i][0] = limit_x_range(arr[i][0],box_bound_xmin,box_bound_xmax,box_bound_xl)
        else:
            new_arr[i][0] = arr[i][0]
        if cuty:        
            new_arr[i][1] = limit_x_range(arr[i][1],box_bound_ymin,box_bound_ymax,box_bound_yl)
        else:
            new_arr[i][1] = arr[i][1]
        if cutz:
            new_arr[i][2] = limit_x_range(arr[i][2],box_bound_zmin,box_bound_zmax,box_bound_zl)
        else:
            new_arr[i][2] = arr[i][2]
        #print(new_arr[i],arr[i], box_bound_ymin,box_bound_ymax)
    return new_arr

def fetch_X_atoms_array(array,column):
    x_array= np.asarray([k for k in array if re.sub(r'\d','',k[column]) == 'X'])
    return x_array


def exposed_Xs_Os_boundary_node(boundary_node_res,connected_nodeedge_fc,sc_unit_cell,box_bound):
    '''look for two nearest Oxys for every exposed(unsaturated X) in boundary nodes'''
    ex_node_cxo_cc=[]
    ex_node_cxo_cc_append=ex_node_cxo_cc.append
    edgex_fvec = filt_edgex_fvec(connected_nodeedge_fc)
    edgex_cvec_array = np.dot(sc_unit_cell,edgex_fvec[:,-3:].T).T

    for i in list(boundary_node_res):
        #count=len(np.where(np.asarray(boundary_node_res)==i)[0])+1 # =1 is because original node + moded_nodes
        node=connected_nodeedge_fc[connected_nodeedge_fc[:,5]==i]
        #res_s_fc=ress_fc.reshape((count,int(ress_fc.shape[0]/count),ress_fc.shape[1]))
        #for n in range(count):
   
        node_center_fc = np.mean(node[:,-3:],axis=0)
        Xs_fc = np.asarray([k[-3:] for k in node if re.sub(r'\d','',k[2]) == 'X'])
        Os_fc = np.asarray([g[-3:] for g in node if re.sub(r'\d','',g[2]) == 'O'])
        Os_cc = np.dot(sc_unit_cell,Os_fc.T).T
        #Xs_fc = np.dot(np.linalg.inv(sc_unit_cell),Xs)
        Xs_fc = Xs_fc.astype(float)
        exposed_Xs_fc=np.asarray([x for x in Xs_fc if not check_nodex_inbox(x.round(4),box_bound)])
        if len(exposed_Xs_fc)>0:
            exposed_Xs_cc=np.dot(sc_unit_cell,exposed_Xs_fc.T).T
            for x in exposed_Xs_cc:
                if check_overlapX(edgex_cvec_array,x):
                    continue
                else:
                    cdist_xos = []
                    cdist_xos_sort = []
                    cdist_xos_append=cdist_xos.append
                    cdist_xos_sort_append=cdist_xos_sort.append
                    for j in range(len(Os_cc)):
                        cvec_o= Os_cc[j]
                        #cvec_xo = np.asarray(cvec_o)-np.asarray(x) 	
                        cvec_xo = cvec_o-x
                        cdist_xo = np.linalg.norm(cvec_xo)
                        cdist_xos_append(cdist_xo)
                        cdist_xos_sort_append(cdist_xo)
                    cdist_xos_sort.sort()
                    cdist_xos_sort3rd=cdist_xos_sort[2]
                    node_ovecs_idx=[index for index,value in enumerate(cdist_xos) if value < cdist_xos_sort3rd]
                    #print(i,n,len(node_ovecs_idx))
                    node_ovecs_cc=[Os_cc[o] for o in node_ovecs_idx]
        
                    ex_node_cxo_cc_append((node_center_fc,len(exposed_Xs_cc),'exposed_X',x,'node_Opair',node_ovecs_cc,node_ovecs_idx))
        
                    #print(f"center{node_center},Xs{len(exposed_Xs_fc)},'\n'{exposed_Xs_cc}")
            #print(res_s.shape)
    return ex_node_cxo_cc





def supercell_nodeedge(supercell_Carte,target_all,sc_unit_cell,box_bound):

    old_res_idx,rescount = fetch_rescount_targetall(target_all)
    fvec_all_info = np.hstack((target_all[:,0:1],target_all[:,4:]))
    info = fvec_all_info

    super_ne = []
    super_ne_info =[]
    fvec_all = np.dot(np.linalg.inv(sc_unit_cell),target_all[:,1:4].T).T
    for i in range(len(supercell_Carte)):
        super_ne.append(supercell_Carte[i]+fvec_all) 
        info=np.concatenate((fvec_all_info, np.asarray([rescount]).T+i*len(old_res_idx)), axis=1)
        super_ne_info.append(info)

    super_ne_array2d=np.vstack((super_ne))
    super_ne_info2d=np.vstack((super_ne_info))
    moded_super_ne_array2d = np.mod(super_ne_array2d,box_bound)
    row_diff = np.any(super_ne_array2d != moded_super_ne_array2d, axis=1)
    row_diff_idx=[i for i in range(len(row_diff)) if row_diff[i]]
    s_fvec_all= np.hstack((super_ne_info2d,super_ne_array2d))
    return s_fvec_all,row_diff_idx


def supercell_nodeedge_fc(supercell_Carte,target_all_fc,box_bound):

    old_res_idx,rescount = fetch_rescount_targetall(target_all_fc)
    fvec_all_info = np.hstack((target_all_fc[:,0:1],target_all_fc[:,4:]))
    info = fvec_all_info

    super_ne = []
    super_ne_info =[]
    fvec_all = target_all_fc[:,1:4]
    for i in range(len(supercell_Carte)):
        super_ne.append(supercell_Carte[i]+fvec_all) 
        info=np.concatenate((fvec_all_info, np.asarray([rescount]).T+i*len(old_res_idx)), axis=1)
        super_ne_info.append(info)

    super_ne_array2d=np.vstack((super_ne))
    super_ne_info2d=np.vstack((super_ne_info))
    moded_super_ne_array2d = np.mod(super_ne_array2d,box_bound)
    row_diff = np.any(super_ne_array2d != moded_super_ne_array2d, axis=1)
    row_diff_idx=[i for i in range(len(row_diff)) if row_diff[i]]
    s_fvec_all= np.hstack((super_ne_info2d,super_ne_array2d))
    return s_fvec_all,row_diff_idx






def supercell_nodeedge_fc_loose_check(supercell_Carte,target_all_fc,box_bound,scalar,cutx,cuty,cutz):
    old_res_idx,rescount = fetch_rescount_targetall(target_all_fc)
    fvec_all_info = np.hstack((target_all_fc[:,0:1],target_all_fc[:,4:]))
    info = fvec_all_info

    super_ne = []
    super_ne_info =[]
    fvec_all = target_all_fc[:,1:4]
    for i in range(len(supercell_Carte)):
        super_ne.append(supercell_Carte[i]+fvec_all) 
        info=np.concatenate((fvec_all_info, np.asarray([rescount]).T+i*len(old_res_idx)), axis=1)
        super_ne_info.append(info)

    super_ne_array2d=np.vstack((super_ne))
    super_ne_info2d=np.vstack((super_ne_info))

    #moded_super_ne_array2d = np.mod(super_ne_array2d,box_bound) #TODO: NOTE: original
    moded_super_ne_array2d = cut_boundary(super_ne_array2d,box_bound,scalar,cutx,cuty,cutz) 
    row_diff = np.any(super_ne_array2d != moded_super_ne_array2d, axis=1)
    row_diff_idx=[i for i in range(len(row_diff)) if row_diff[i]]
    s_fvec_all= np.hstack((super_ne_info2d,super_ne_array2d))
    return s_fvec_all,row_diff_idx


def filt_boundary_res(s_fvec_all,row_diff_idx,box_bound):
    res_count_idx = set(s_fvec_all[:,-4])
    differ_res_idx = set([s_fvec_all[i][-4] for i in row_diff_idx])
    #print(f"differ res idx{differ_res_idx}")

    inside_res=[]
    extra_res=[]
    kick_res = []
    inside_res_append = inside_res.append
    extra_res_append = extra_res.append
    kick_res_append = kick_res.append
    boundary_node_res = []
    boundary_node_res_append = boundary_node_res.append
    for i in res_count_idx:
        if i in differ_res_idx:
            res=s_fvec_all[s_fvec_all[:,5]==i]
            original_fvec = res[:,-3:]
            original_fvec = original_fvec.astype(float)
            moded_fvec = np.mod(original_fvec,box_bound)
            row_diff = diff_rows_count_two_array(original_fvec,moded_fvec)
            if res[0,4]=='EDGE' or res[0,4]=='TEDGE' and len(row_diff)>(res.shape[0]-3):
                #print(f"see EDGE{i}")
                #check if twoX sit on boundary with a tiny shift range
                if not check_edgex_sits_inboundary(original_fvec[2],original_fvec[5],box_bound):
                    #print(f"kick{i}")
                    #print(f"69 {len(row_diff)}len(row_diff){res.shape[0]}original_fvec{original_fvec}\n{moded_fvec}")
                    kick_res_append(i)  
            diff = [moded_fvec[i]-original_fvec[i] for i in row_diff]
            if len(diff) >0:
                diff =np.vstack(diff).astype(float)
            else:
                diff = np.zeros((1,3))
            diffs=np.unique(diff,axis=0)
            diff_ele=split_diffs(diffs)
            #print('\n',diff_ele,'\n',diffs,'\n')
            for diff_e in diff_ele:
                if res[0,4]=='NODE':
                    t_res =  np.hstack((res[:,:6],res[:,-3:] + np.asarray(diff_e)))
                    boundary_node_res_append(i)
                    extra_res_append(t_res)
                elif res[0,4]=='EDGE'or res[0,4]=='TEDGE':
                    check1 = np.mean(res[[2,5],-3:],axis=0) + np.asarray(diff_e)
                    check1=check1.astype(float)
                    check1 = np.round(check1,4)
                    #print(i,diff_e,check1)
                    if check_edge_center_inbox(check1,box_bound):
                        #print(i,diff_e)
                        #print(i,np.round(t_res_xyz[:6],5),np.round(np.mod(t_res_xyz[:6],[1,1,1]),5),diff_e)
                        t_res =  np.hstack((res[:,:6],res[:,-3:] + np.asarray(diff_e)))
                        extra_res_append(t_res)
        else:
            res=s_fvec_all[s_fvec_all[:,5]==i]
            inside_res_append(res)
    if len(extra_res)>0:
        extra_res_arr=np.vstack(extra_res)  
    else:
        extra_res_arr=np.empty((0,9))
    #inside_res_arr = np.vstack(inside_res)
    safe_res=[s for s in s_fvec_all if s[5] not in kick_res]
    
    return safe_res,extra_res_arr,boundary_node_res




def filt_boundary_res_loose_check(s_fvec_all,row_diff_idx,box_bound,scalar,cutx,cuty,cutz,boundary_scalar):
    res_count_idx = set(s_fvec_all[:,-4])
    differ_res_idx = set([s_fvec_all[i][-4] for i in row_diff_idx])
    #print(f"differ res idx{differ_res_idx}")
    #print(f"diff_ros{len(row_diff_idx)}, diff_res{len(differ_res_idx)}")

    inside_res=[]
    extra_res=[]
    kick_res = []
    inside_res_append = inside_res.append
    extra_res_append = extra_res.append
    kick_res_append = kick_res.append
    boundary_node_res = []
    boundary_node_res_append = boundary_node_res.append
    for i in res_count_idx:
        if i in differ_res_idx:
            res=s_fvec_all[s_fvec_all[:,5]==i]
            original_fvec = res[:,-3:]
            original_fvec = original_fvec.astype(float)
            #moded_fvec = np.mod(original_fvec,box_bound) #TODO: NOTE:
            moded_fvec = cut_boundary(original_fvec,box_bound,scalar,cutx,cuty,cutz)
            #print(f"original{original_fvec} moded{moded_fvec}")
            row_diff = diff_rows_count_two_array(original_fvec,moded_fvec)
            #print(f"row_diff{row_diff},original{original_fvec} moded{moded_fvec}")
            #if (res[0,4]=='EDGE' or res[0,4]=='TEDGE') and len(row_diff)>(res.shape[0]-4):
            #    #check if twoX sit on boundary with a tiny shift range
            #    if not check_edgex_sits_inboundary(original_fvec[2],original_fvec[5],box_bound):
            #        print(f"kick{i}")
            #        #print(f"69 {len(row_diff)}len(row_diff){res.shape[0]}original_fvec{original_fvec}\n{moded_fvec}")
            #        kick_res_append(i)  
            diff = [moded_fvec[i]-original_fvec[i] for i in row_diff]
            if len(diff) >0:
                diff =np.vstack(diff).astype(float)
            else:
                diff = np.zeros((1,3))
            diffs=np.round(np.unique(diff,axis=0),1)
            diff_ele=split_diffs(diffs)
            #print('\n',diff_ele,'\n',diffs,'\n')
            for diff_e in diff_ele:
                if res[0,4]=='NODE':
                    t_res =  np.hstack((res[:,:6],res[:,-3:] + np.asarray(diff_e)))
                    boundary_node_res_append(i)
                    extra_res_append(t_res)
                elif res[0,4]=='EDGE' or res[0,4]=='TEDGE':
                    x_atoms=fetch_X_atoms_array(res,2)
                    check1 = np.mean(x_atoms[:,-3:],axis=0) + np.asarray(diff_e) #edge_center
                    #check1=check1.astype(float)
                    #check1 = np.round(check1,1)
                    #print(i,diff_e,check1)
                    if  check_edge_center_inbox_loose(check1,box_bound,boundary_scalar):
                        #print("in",i,diff_e)
                        #print(i,np.round(t_res_xyz[:6],5),np.round(np.mod(t_res_xyz[:6],[1,1,1]),5),diff_e)
                        t_res =  np.hstack((res[:,:6],res[:,-3:] + np.asarray(diff_e)))
                        extra_res_append(t_res)
        else:
            res=s_fvec_all[s_fvec_all[:,5]==i]
            inside_res_append(res)
    if len(extra_res)>0:
        extra_res_arr=np.vstack(extra_res)  
    else:
        extra_res_arr=np.empty((0,9))
    #inside_res_arr = np.vstack(inside_res)
    safe_res=[s for s in s_fvec_all if s[5] not in kick_res]
    
    return safe_res,extra_res_arr,boundary_node_res


def cluster_supercell(sc_unit_cell,supercell_Carte,linker_topics,target_all_fc,box_bound,scalar,cutx,cuty,cutz,boundary_scalar):
    s_fvec_all_loose,row_diff_idx_loose = supercell_nodeedge_fc_loose_check(supercell_Carte,target_all_fc,box_bound,scalar,cutx,cuty,cutz) 
    print("row_diff_idx_loose",row_diff_idx_loose)
    safe_res_fc_loose,extra_res_fc_loose,boundary_node_res_loose = filt_boundary_res_loose_check(s_fvec_all_loose,row_diff_idx_loose,box_bound,scalar,cutx,cuty,cutz,boundary_scalar)
    bare_nodeedge_fc_loose=np.vstack((safe_res_fc_loose,extra_res_fc_loose))
    connected_nodeedge_fc_loose, boundary_connected_nodes_res,eG =  filter_connected_node_loose(bare_nodeedge_fc_loose,boundary_node_res_loose,linker_topics,sc_unit_cell)
    return connected_nodeedge_fc_loose, boundary_connected_nodes_res,eG,bare_nodeedge_fc_loose